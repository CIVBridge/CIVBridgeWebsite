<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CIV Group 203 Codes</title>
  <style>
    body {
      font-family: Courier, sans-serif;
      margin: 0;
      padding: 0;
      color: white;
      background-color: #000;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }

    .container {
      position: relative;
      z-index: 1;
      max-width: 800px;
      margin: 50px auto;
      text-align: center;
      padding: 20px;
    }

    h1 {
      background: #14213D;
      color: #FFFFFF;
      margin: 0;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 4px 15px rgba(113, 156, 255, 0.4);
    }

    .tabs {
      display: flex;
      justify-content: center;
      margin: 20px 0;
    }

    .tab-button {
      padding: 15px 30px;
      margin: 0 10px;
      cursor: pointer;
      border: none;
      background: #808080;
      color: #000;
      font-size: 16px;
      font-weight: bold;
      font-family: "Courier";
      border-radius: 20px;
      box-shadow: 0px 5px 15px rgba(113, 156, 255, 0.4), 0px -2px 5px rgba(0, 0, 0, 0.3);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .tab-button:hover {
      transform: translateY(-3px);
      box-shadow: 0px 7px 20px rgba(255, 255, 255, 0.6), 0px -4px 7px rgba(0, 0, 0, 0.5);
    }

    .tab-button.active {
      background: linear-gradient(145deg, #14213D, #14213D);
      color: #FFFFFF;
    }

    .tab-content {
      padding: 20px;
      display: none;
      text-align: left;
    }

    .tab-content.active {
      display: block;
    }

    .fancy-subheading {
      font-size: 20px;
      font-family: "Courier";
      color: #7393B3;
      text-shadow: 1px 1px 2px #1537d2;
      margin-bottom: 10px;
    }

    pre {
      background: #121212;
      padding: 15px;
      border-radius: 8px;
      overflow: auto;
      box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
      color: #F5F5F5;
    }

    code {
      font-family: Courier;
      color: #a3a0a0;
      font-size: 14px;
      line-height: 1.8;
      background-color: #121212;
      padding: 5px;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <canvas id="bouncingCanvas"></canvas>

  <div class="container">
    <h1>CIV Group 203 Codes</h1>
    <div class="tabs">
      <button class="tab-button active" onclick="switchTab('python')">Python Code</button>
      <button class="tab-button" onclick="switchTab('java')">Java Code</button>
    </div>
    <div id="python" class="tab-content active">
      <div class="fancy-subheading">Python Code For SFE and BME</div>
      <pre><code>
import numpy as np 
import matplotlib.pyplot as plt 
#python libraries to graph SFD and BMD

class Load:
    @staticmethod
    def change(f, d):
        return f, d

def calculate(x,n):
    load_data1 = [
        (200/3, -855), (200/3, -679), (200/3, -515), (200/3, -339),
        (200/3, -175), (200/3, 0)
    ]
    #case 1

    load_data2 = [
        (67.45, -855), (67.45, -679), (67.45, -515), (67.45, -339),
        (91.05, -175), (91.05, 0)
    ]
    #case 2

    load_data3 = [
        (1.1*138.66, -855), (1.1*138.66, -679), (1*138.66, -515), (1*138.66, -339),
        (1.485*138.66, -175), (1.485*138.66, 0)
    ]
    #case 3 (P)

    types = [load_data1, load_data2, load_data3]
    forceList, distanceList = zip(*(Load.change(f, d) for f, d in types[x]))
    distanceList = list(distanceList)
    forceList = list(forceList)
    #create to forceList and distanceList

    FYList = []
    rollerList = []
    pinList = []
    big_shear_force = []
    max_shear_force = []
    for i in range(1251):
        max_shear_force.append([])
    final_shear_force = []
    max_bending_moment = []
    for i in range(1251):
        max_bending_moment.append([])
    final_bending_moment = []
    big_bending_moment = []
    max_point_on_train_shear = []
    max_point_on_train_moment = []
    sheartest = []
    momenttest = []
    global individual
    individual = 0
    #initializing variables

    for _ in range(2106):
        FY = 0
        Moment = 0
        relevantForcesList = []
        relevantDistancesList = []
        newsortedForceList = []
        key = 0
        sum = 0
        filledForcesList = []
        current_force_index = 0
        #initilizing iteration reset variables

        for j, (force, distance) in enumerate(zip(forceList, distanceList)):
            if 0 <= distanceList[j] <= 1250:
                FY += force #cumulate Force in Y-direction
                relevantForcesList.append(-1*force) #cumulate Forces on beam
                relevantDistancesList.append(distanceList[j]) #cumulate Forces on beam
                Moment += (distanceList[j] - 25) * force #cumulate Moments
            distanceList[j] += 1 #add train movement by 1mm on the beam

        roller_force = Moment / 1200 #calculate roller force
        pin_force = FY - roller_force #calculate pin force

        FYList.append(FY) 
        rollerList.append(roller_force)
        pinList.append(pin_force)
        #append to respective lists

        relevantForcesList = [0, pin_force] + relevantForcesList + [roller_force, 0]
        relevantDistancesList = [0, 25] + relevantDistancesList + [1225, 1250]
        #add edge bounds to both distance and force lists

        paired_lists = list(zip(relevantDistancesList, relevantForcesList))
        paired_lists.sort(key=lambda x: x[0])
        sortedDistancesList, sortedForcesList = zip(*paired_lists)
        sortedDistancesList = list(sortedDistancesList)
        sortedForcesList = list(sortedForcesList)
        #sort both lists

        for i in range(len(sortedForcesList)):
            sum += sortedForcesList[i]
            newsortedForceList.append(sum)

        ''' Fill in distance and force lists to include all points on the beam, creating horizontal 
        lines between distances and force value-drops'''
        min_distance = sortedDistancesList[0]
        max_distance = sortedDistancesList[-1]

        step_size = 1
        filledDistancesList = list(range(min_distance, max_distance + 1, step_size))

        for distance in filledDistancesList:
            if (current_force_index < len(sortedDistancesList) and 
                    distance > sortedDistancesList[current_force_index + 1]):
                current_force_index += 1
            filledForcesList.append(newsortedForceList[current_force_index])
        big_shear_force.append(filledForcesList)
        big_bending_moment.append(np.cumsum(filledForcesList))

        if (_ == n):
            sheartest = filledForcesList
            momenttest = list(np.cumsum(filledForcesList))

    '''convert the data in terms of position of the train movement to position of the beam 
    length (inverse the matrix of 2106x1251 to 1251x2106)'''
    for i in range(len(big_shear_force)):
        for j in range(len(big_shear_force[i])):
            max_shear_force[j].append(big_shear_force[i][j])

    for i in range(len(big_bending_moment)):
        for k in range(len(big_bending_moment[i])):
            max_bending_moment[k].append(big_bending_moment[i][k])

    for i in range(len(max_shear_force)):
        final_shear_force.append(max(abs(number) for number in max_shear_force[i]))
        final_bending_moment.append(max(number for number in max_bending_moment[i]))
        max_point_on_train_shear.append(max(range(len(max_shear_force[i])), key=lambda x: abs(max_shear_force[i][x])))
        #max_point_on_train_shear.append(max(range(len(max_shear_force[i])), key=max_shear_force[i].__getitem__))
        max_point_on_train_moment.append(max(range(len(max_bending_moment[i])), key=max_bending_moment[i].__getitem__))

    #fix end bounds
    final_shear_force.append (0)
    sheartest.append(0)
    momenttest.append(0)
    final_bending_moment.append(0)
    filledDistancesList.append(filledDistancesList[-1]+1)
    return [filledDistancesList, final_shear_force, final_bending_moment, sheartest, momenttest, max_point_on_train_shear, max_point_on_train_moment]

def plot(type, n):
    global individual
    if (individual != 1):
        data = calculate(type,0)
        x,y,z,max_point_on_train_shear,max_point_on_train_bending = data[0], data[1], data[2], data[5], data[6]
    else:
        data = calculate(type,n)
        x,y,z,max_point_on_train_shear,max_point_on_train_bending = data[0], data[3], data[4], data[5], data[6]


    '''PLOT'''
    #print maximum of shear and moment out of the entire maximum plots to console
    print((f"Total Max Shear (N) is: {max(y)}, Slide Rule: {int(float(f'{max(y):.3g}'))}") if (str(int(max(y)))[0] != "1")
        else (f"Total Max Shear (N) is: {max(y)}, Slide Rule: {int(float(f'{max(y):.4g}'))}"))
    print((f"Total Max Moment (N*mm) is: {max(z)}, Slide Rule: {int(float(f'{max(z):.3g}'))}") if (str(int(max(z)))[0] != "1")
        else (f"Total Max Moment (N*mm) is: {max(z)}, Slide Rule: {int(float(f'{max(z):.4g}'))}"))

    print("-"*80)
    print(z[437])
    print(z[813])
    #Print to confirm with calculations by hand
    print(f"This Max Shear (N) occured at: {x[y.index(max(y))]-1}mm, Front Wheel of Train has moved: {max_point_on_train_shear[y.index(max(y))]}mm.")
    print(f"This Max Moment (N*mm) occured at: {x[z.index(max(z))]-1}mm, Front Wheel of Train has moved: {max_point_on_train_bending[z.index(max(z))]}mm.")


    fig = plt.figure()

    shear = fig.add_subplot(121)
    shear.plot(x,y, color='blue')
    shear.set_title('Shear Force Envelope')
    shear.set_xlabel('Position on Beam (mm)')
    shear.set_ylabel('Shear Force (N)')
    original_number = max(y, key=abs)
    plt.plot(x[y.index(original_number)], original_number, ms=5, marker='o', color='green')  # Added color for visibility
    plt.text(
        x[y.index(original_number)] - 5,  
        original_number + 5,              
        f"{x[y.index(original_number)]-1, int(float(f'{original_number:.3g}'))}", 
        ha="right",                       
        va="bottom"                       
    )


    moment = fig.add_subplot(122)
    moment.plot(x,z, color='red')
    moment.set_title('Bending Moment Envelope')
    moment.set_xlabel('Position on Beam (mm)')
    moment.set_ylabel('Bending Moment (N*mm)')
    plt.plot(x[z.index(max(z))],max(z),ms = 5, marker='o', color='green')
    plt.text(
    x[z.index(max(z))] - 5,    
    max(z) + 5,               
    f"{x[z.index(max(z))]-1, int(float(f'{max(z):.3g}'))}"  ,
    ha="right",                       
    va="bottom"                
)

    plt.show()

def individualplot(type, n):
    global individual
    individual = 1
    plot(type,n)

if __name__ == "__main__":
    individual = 0
    plot(0,0)
    #individualplot(1, 1225)
      </code></pre>
    </div>
    <div id="java" class="tab-content">
      <div class="fancy-subheading">Java Code For Cross-Section Calculations</div>
      <pre><code>

abstract class Shape {
    // ****** This class allows for any shape to be added to a cross section, 
    //        but we ended up using only rectangles
    // ******
    private double length = -1.0;
    private double height;
    private double base;
    private double bottomDist;

    // Constructor for diagonal shapes
    public Shape(double length, double height, double base, double bottomDist){
        this.length = length;
        this.height = height;
        this.base = base;
        this.bottomDist = bottomDist;
    }

    //Constructor for vertical or horizontal shapes
    public Shape(double height, double base, double bottomDist){
        this.height = height;
        this.base = base;
        this.bottomDist = bottomDist;
    }


    public double getLength() {
        return this.length;
    }

    public double getHeight() {
        return this.height;
    }

    public double getBase() {
        return this.base;
    }

    public double getBotDist() {
        // ****** This function returns the distance between the bottom of the shape and the bottom of the cross section
        // ******
        return this.bottomDist;
    }

    public double getHighestPoint() {
        // ****** This function returns the highest point of the shape relative to the bottom of the cross section
        // ******
        return this.height + this.bottomDist;
    }

    public abstract double getArea();

    public abstract double getCentroid();

    public abstract double getIown();
}

public class Rectangle extends Shape{
    public Rectangle (double length, double height, double base, double botWholeToBotShape) {
        // ****** This constructor is used for rectangles at a diagonal
        //        length and base represent the actual dimensions of the rectangle
        //        height represents the vertical height of the diagonal rectangle perpendicular to the centroid of the cross section
        // ******
        super(length, height, base, botWholeToBotShape);
    }

    public Rectangle (double height, double base, double botWholeToBotShape) {
        super(height, base, botWholeToBotShape);
    }

    @Override
    public double getArea() {
        // ****** This function returns the area of a rectangle
        // ******
        if (getLength() >= 0) {
            return getLength()*getBase();
        }
        return getHeight()*getBase();
    }

    @Override
    public double getCentroid() {
        // ****** This function returns the centroid of a rectangle relative to the bottom of the cross section
        // ******
        return getBotDist() + getHeight()/2;
    }

    @Override
    public double getIown() {
        // ****** This function returns the Iown of a rectangle
        // ******
        return (getBase() * Math.pow(getHeight(), 3)) / 12;
    }
}

import java.util.*;

public class CrossSection {
    // These values were taken from "CIV102 Matboard Bridge Design Project" (2024)
    private static final double THICK_MAT = 1.27;
    private static final double TENS_MAX_MAT = 30;
    private static final double COMP_MAX_MAT = 6;
    private static final double TAU_MAX_MAT = 4;
    private static final double YOUNGS_MAT = 4000;
    private static final double TAU_MAX_GLUE = 2;
    private static final double POISSON = 0.2;

    // This is the collection of shapes that make up the cross section
    private ArrayList<Shape> components;

    // Constructor
    public CrossSection() {
        this.components = new ArrayList<>(20);
    }

    public void addRect(double l, double h, double b, double botDist) {
        // ****** This function adds a diagonal rectangle to the cross section
        // ******
        this.components.add(new Rectangle(l, h, b, botDist));
    }

    public void addRect(double h, double b, double botDist) {
        // ****** This function adds a vertical or horizontal rectangle to the cross
        // section
        // ******
        this.components.add(new Rectangle(h, b, botDist));
    }

    public double getYbar() {
        // ****** This function calculates the yBar for the cross section
        // This also serves as the distance from the bottom to the centroid of the cross
        // section (yBot)
        // ******
        double sumAy = 0.0;
        double sumA = 0.0;
        for (Shape shape : this.components) {
            sumA += shape.getArea();
            sumAy += shape.getArea() * shape.getCentroid();
        }
        return sumAy / sumA;
    }

    public double getYtop() {
        // ****** This function calculates the distance from the top to the centroid of
        // the cross section (yTop)
        // ******
        double maxHeight = 0.0;
        for (Shape shape : this.components) {
            if (shape.getHighestPoint() > maxHeight) {
                maxHeight = shape.getHighestPoint();
            }
        }
        return maxHeight - getYbar();
    }

    public double getI() {
        // ****** This function calculates the second moment of area I for the cross
        // section
        // ******
        double sumIown = 0.0;
        double sumIpar = 0.0;
        for (Shape shape : this.components) {
            sumIown += shape.getIown();
            sumIpar += (shape.getArea() * Math.pow((shape.getCentroid() - getYbar()), 2));
        }
        return sumIown + sumIpar;
    }

    public double getQ(double hOfInterest) {
        // ****** This function calculates the first moment of area Q at a given height
        // of the cross section (hOfInterest)
        // It always uses the top of the cross section as the stress-free surface
        // ******
        double sumAdist = 0;
        for (Shape shape : this.components) {
            if (shape.getBotDist() >= hOfInterest) {
                double dist = shape.getCentroid() - getYbar();
                sumAdist += shape.getArea() * dist;
            } else if (shape.getHighestPoint() > hOfInterest) {
                double A = shape.getArea() * (shape.getHighestPoint() - hOfInterest) / shape.getHeight();
                double dist = (shape.getHighestPoint() - getYbar()) / 2;
                sumAdist += A * dist;
            }
        }
        return sumAdist;
    }

    public double getMinB(double hOfInterest) {
        // ****** This function calculates the smallest horizontal width b at given
        // height of the cross section (hOfInterest)
        // ******
        double sumWidths = 0;
        double sumLowers = 0;
        double sumHighers = 0;
        for (Shape shape : this.components) {
            if (shape.getBotDist() < hOfInterest && shape.getHighestPoint() > hOfInterest) {
                sumWidths += shape.getBase();
            } else if (shape.getBotDist() == hOfInterest) {
                sumHighers += shape.getBase();
            } else if (shape.getHighestPoint() == hOfInterest) {
                sumLowers += shape.getBase();
            }
        }
        double lowerB = sumLowers + sumWidths;
        double higherB = sumHighers + sumWidths;
        if (lowerB == 0) {
            return higherB;
        } else if (higherB == 0) {
            return lowerB;
        }
        return Math.min(lowerB, higherB);
    }

    public double flex_stress(double Mmax, double y) {
        // ****** This function calculates flexural stress for a given moment (Mmax) and
        // distance from centroid (y)
        // ******
        return (Mmax * y) / getI();
    }

    public double shear_stress(double V, double hOfInterest) {
        // ****** This function calculates shear stress for a given shear force (V) at a
        // given height axis (hOfInterest)
        // ******
        return (V * getQ(hOfInterest)) / (getI() * getMinB(hOfInterest));
    }

    public double shear_glue(double V, double hOfInterest, double glueWidth) {
        // ****** This function calculates the shear stress experienced by glue for a
        // given shear force (V) at a given height (hOfInterest)
        // for a given width of glue applied (glueWidth)
        // ******
        return (V * getQ(hOfInterest)) / (getI() * glueWidth);
    }

    public double flex_buck(double k, double E, double mew, double t, double w) {
        // ****** This function calculates local buckling stress on a member for a given
        // constant k (k), Young's modulus (E),
        // Poisson's ratio (mew), member thickness (t), and member width (w)
        // ******
        return (k * (Math.PI * Math.PI) * E * Math.pow((t / w), 2)) / (12 * (1 - mew * mew));
    }

    public double shear_buck(double E, double mew, double t, double h, double deltaDiaph) {
        // ****** This function calculates shear buckling stress on the web for a given
        // constant k (k), Young's modulus (E),
        // Poisson's ratio (mew), web thickness (t), and diaphragm distance (deltaDiaph)
        // ******
        return (5 * (Math.PI * Math.PI) * E
                * (Math.pow((t / h), 2) + Math.pow((t / deltaDiaph), 2)))
                / (12 * (1 - mew * mew));
    }

    public void printFOSAnalysis(double Mmax, double Vmax, ArrayList<Double> glueHeights,
            ArrayList<Integer> buckCaseLayers, ArrayList<Double> buckCaseWidths, double distDiaph) {
        // ****** This function calculates the flexural stresses, shear stresses, and
        // local buckling stresses on a cross section
        // for a given max applied moment (Mmax) and shear force (Vmax)
        // It calculates the shear stress experienced by glue at all heights where glue
        // is applied (glueHeights)
        // It requires given lists of thickness (buckCaseLayers) and width
        // (buckCaseWidths) values for local buckling cases
        // For Case 4 buckling, it requires a given diaphragm distance
        // The function then calculates all the factors of safety (FOS) for each failure
        // method
        // ******
        double tens_stress = flex_stress(Mmax, getYbar());
        double comp_stress = flex_stress(Mmax, getYtop());
        double shear_max = shear_stress(Vmax, getYbar());
        ArrayList<Double> glue_stresses = new ArrayList<>();
        double maxGlueStress = -1.0;
        for (Double h : glueHeights) {
            double ss = shear_stress(Vmax, h);
            glue_stresses.add(ss);
            if (ss > maxGlueStress) {
                maxGlueStress = ss;
            }
        }
        double case1stress = flex_buck(4, YOUNGS_MAT, POISSON, THICK_MAT * buckCaseLayers.get(0),
                buckCaseWidths.get(0));
        double case2stress = flex_buck(0.425, YOUNGS_MAT, POISSON, THICK_MAT * buckCaseLayers.get(1),
                buckCaseWidths.get(1));
        double case3stress = flex_buck(6, YOUNGS_MAT, POISSON, THICK_MAT * buckCaseLayers.get(2),
                buckCaseWidths.get(2));
        double case4stress = shear_buck(YOUNGS_MAT, POISSON, THICK_MAT * buckCaseLayers.get(3), buckCaseWidths.get(3),
                distDiaph);

        double FOStens = TENS_MAX_MAT / tens_stress;
        double FOScomp = COMP_MAX_MAT / comp_stress;
        double FOSshear = TAU_MAX_MAT / shear_max;
        double FOSglue = TAU_MAX_GLUE / maxGlueStress;
        double FOSbuck123 = Math.min(Math.min(case1stress, case2stress), case3stress) / comp_stress;
        double FOSshearbuck = case4stress / shear_max;

        System.out.println("For Neutral Axis, Q = " + getQ(getYbar()) + " mm^3");
        for (int k = glueHeights.size(); k > 0; k--) {
            System.out.println("For Axis " + k + ", Q = " + getQ(glueHeights.get(k - 1)) + " mm^3");
        }
        System.out.println();

        System.out.println("\nApplied Tens Flexural:  " + tens_stress + " MPa\nFOStens = " + FOStens + "\n");
        System.out.println("Applied Comp Flexural:  " + comp_stress + " MPa\nFOScomp = " + FOScomp + "\n");
        System.out.println("Applied Shear Mat:  " + shear_max + " MPa\nFOSshear = " + FOSshear + "\n");
        System.out.print("Applied Glue Stresses:  ");
        for (double stress : glue_stresses) {
            System.out.print(stress + " MPa    ");
        }
        System.out.println("\nFOSglue = " + FOSglue + "\n");
        System.out.println("Case 1 MAX:  " + case1stress + " MPa\nCase 2 MAX:  " + case2stress + " MPa\nCase 3 MAX:  "
                + case3stress + " MPa\nFOSbuck123 = " + FOSbuck123 + "\n");
        System.out.println("Shear Buck MAX:  " + case4stress + " MPa\nFOSshearbuck = " + FOSshearbuck + "\n\n");
        System.out
                .println("FOStens = " + FOStens + "\nFOScomp = " + FOScomp + "\nFOSshear = " + FOSshear + "\nFOSglue = "
                        + FOSglue + "\nFOSbuck123 = " + FOSbuck123 + "\nFOSshearbuck = " + FOSshearbuck + "\n\n");
    }

    public void printFullAnalysis(double Mmax, double Vmax, double Mratio, double Vratio,
            ArrayList<Double> glueHeights, double glueWidth,
            ArrayList<Integer> buckCaseLayers, ArrayList<Double> buckCaseWidths, double distDiaph) {
        // ****** This function calculates the flexural stresses, shear stresses, and
        // local buckling stresses on a cross section
        // for a given max applied moment (Mmax) and shear force (Vmax)
        // It calculates the shear stress experienced by glue at all heights where glue
        // is applied (glueHeights) for a given width of glue applied (glueWidth)
        // It requires given lists of thickness (buckCaseLayers) and width
        // (buckCaseWidths) values for local buckling cases
        // For Case 4 buckling, it requires a given diaphragm distance
        // Next, the function calculates all the factors of safety (FOS) for each
        // failure method
        // Finally, the function calculates the failure load P and the maximum weight of
        // the train that will cause the cross section to fail
        // ******
        double tens_stress = flex_stress(Mmax, getYbar());
        double comp_stress = flex_stress(Mmax, getYtop());
        double shear_max = shear_stress(Vmax, getYbar());
        ArrayList<Double> glue_stresses = new ArrayList<>();
        double maxGlueStress = -1.0;
        for (Double h : glueHeights) {
            double ss = shear_glue(Vmax, h, glueWidth);
            glue_stresses.add(ss);
            if (ss > maxGlueStress) {
                maxGlueStress = ss;
            }
        }
        double case1stress = flex_buck(4, YOUNGS_MAT, POISSON, THICK_MAT * buckCaseLayers.get(0),
                buckCaseWidths.get(0));
        double case2stress = flex_buck(0.425, YOUNGS_MAT, POISSON, THICK_MAT * buckCaseLayers.get(1),
                buckCaseWidths.get(1));
        double case3stress = flex_buck(6, YOUNGS_MAT, POISSON, THICK_MAT * buckCaseLayers.get(2),
                buckCaseWidths.get(2));
        double case4stress = shear_buck(YOUNGS_MAT, POISSON, THICK_MAT * buckCaseLayers.get(3), buckCaseWidths.get(3),
                distDiaph);
        ArrayList<Double> buckStresses = new ArrayList<>(
                Arrays.asList(case1stress, case2stress, case3stress, case4stress));

        double FOStens = TENS_MAX_MAT / tens_stress;
        double FOScomp = COMP_MAX_MAT / comp_stress;
        double FOSshear = TAU_MAX_MAT / shear_max;
        double FOSglue = TAU_MAX_GLUE / maxGlueStress;
        double FOSbuck123 = Math.min(Math.min(case1stress, case2stress), case3stress) / comp_stress;
        double FOSshearbuck = case4stress / shear_max;

        System.out.println("For Neutral Axis, Q = " + getQ(getYbar()) + " mm^3");
        for (int k = glueHeights.size(); k > 0; k--) {
            System.out.println("For Axis " + k + ", Q = " + getQ(glueHeights.get(k - 1)) + " mm^3");
        }
        System.out.println();

        System.out.println("Applied Tens Flexural:  " + tens_stress + " MPa\nFOStens = " + FOStens + "\n");
        System.out.println("Applied Comp Flexural:  " + comp_stress + " MPa\nFOScomp = " + FOScomp + "\n");
        System.out.println("Applied Shear Mat:  " + shear_max + " MPa\nFOSshear = " + FOSshear + "\n");
        System.out.print("Applied Glue Stresses:  ");
        for (double stress : glue_stresses) {
            System.out.print(stress + " MPa    ");
        }
        System.out.println("\nFOSglue = " + FOSglue + "\n");
        System.out.println("Case 1 MAX:  " + case1stress + " MPa\nCase 2 MAX:  " + case2stress + " MPa\nCase 3 MAX:  "
                + case3stress + " MPa\nFOSbuck123 = " + FOSbuck123 + "\n");
        System.out.println("Shear Buck MAX:  " + case4stress + " MPa\nFOSshearbuck = " + FOSshearbuck + "\n\n");
        System.out
                .println("FOStens = " + FOStens + "\nFOScomp = " + FOScomp + "\nFOSshear = " + FOSshear + "\nFOSglue = "
                        + FOSglue + "\nFOSbuck123 = " + FOSbuck123 + "\nFOSshearbuck = " + FOSshearbuck + "\n\n");

        printFailurePs(Mratio, Vratio, glueHeights, glueWidth, buckStresses);
    }

    public double PfailFlex(double sigmaMax, double Mratio, double y) {
        // ****** This function calculates the load P that will cause failure for a
        // given flexural failure stress (sigmaMax),
        // a given applied moment in terms of P (Mratio), and a given distance from
        // centroid (y)
        // ******
        return (sigmaMax * getI()) / (Mratio * y);
    }

    public double PfailShear(double tauMax, double Vratio, double hOfInterest) {
        // ****** This function calculates the load P that will cause failure for a
        // given shear failure stress (tauMax),
        // a given applied shear in terms of P (Vratio), and a given height of the cross
        // section (hOfInterest)
        // ******
        return (tauMax * getI() * getMinB(hOfInterest)) / (Vratio * getQ(hOfInterest));
    }

    public double PfailGlue(double tauMax, double Vratio, double hOfInterest, double glueWidth) {
        // ****** This function calculates the load P that will cause glue failure for a
        // given glue shear failure stress (tauMax),
        // a given applied shear in terms of P (Vratio), a given height of the cross
        // section (hOfInterest),
        // and a given width of glue applied
        // ******
        return (tauMax * getI() * glueWidth) / (Vratio * getQ(hOfInterest));
    }

    public void printFailurePs(double Mratio, double Vratio, ArrayList<Double> glueHeights, double glueWidth,
            ArrayList<Double> buckStresses) {
        // ****** This function calculates the load P that will cause the cross section
        // to fail by flexural, shear material, shear glue, and local buckling failures
        // for a given applied moment in terms of P (Mratio) and shear force in terms of
        // P (Vratio)
        // It calculates failure load P for glue by shear at all heights where glue is
        // applied (glueHeights) for a given width of glue applied (glueWidth)
        // It calculates failure load P for local buckling if any of the 4 cases
        // (buckStresses) yield a lower failure stress than the material's failure
        // stresses
        // The load P represents the force applied by the lightest wheel of the train
        // and is multiplied by the ratios for successive tests in Load Case 2
        // to find the maximum weight of the train that the cross section can support
        // ******
        ArrayList<Double> allPFails = new ArrayList<>();

        double PflexTens = PfailFlex(TENS_MAX_MAT, Mratio, getYbar());
        allPFails.add(PflexTens);
        System.out.println("Pfail Flex Tens: " + PflexTens + " N");

        double PflexComp = PfailFlex(COMP_MAX_MAT, Mratio, getYtop());
        allPFails.add(PflexComp);
        System.out.println("Pfail Flex Comp: " + PflexComp + " N");

        double PshearMat = PfailShear(TAU_MAX_MAT, Vratio, getYbar());
        allPFails.add(PshearMat);
        System.out.println("Pfail Shear Matboard: " + PshearMat + " N");

        for (Double h : glueHeights) {
            double Pfail = PfailGlue(TAU_MAX_GLUE, Vratio, h, glueWidth);
            allPFails.add(Pfail);
            System.out.println("Pfail Shear Glue: " + Pfail + " N       at height " + h + " mm");
        }

        double PbuckCase1 = PfailFlex(buckStresses.get(0), Mratio, getYtop());
        allPFails.add(PbuckCase1);
        System.out.println("Pfail Case 1 Buck: " + PbuckCase1 + " N");

        double PbuckCase2 = PfailFlex(buckStresses.get(1), Mratio, getYtop());
        allPFails.add(PbuckCase2);
        System.out.println("Pfail Case 2 Buck: " + PbuckCase2 + " N");

        double PbuckCase3 = PfailFlex(buckStresses.get(2), Mratio, getYtop());
        allPFails.add(PbuckCase3);
        System.out.println("Pfail Case 3 Buck: " + PbuckCase3 + " N");

        double PbuckCase4 = PfailShear(buckStresses.get(3), Vratio, getYbar());
        allPFails.add(PbuckCase4);
        System.out.println("Pfail Case Shear Buck: " + PbuckCase4 + " N");

        allPFails.sort(null);
        double Pfailure = allPFails.get(0);
        System.out.println("\n\nThe bridge will fail at P = " + Pfailure + " N");

        double trainWeight = Pfailure * (1 + 1 + 1.1 + 1.1 + 1.1 * 1.35 + 1.1 * 1.35);
        System.out.println(
                "This is when the middle car is " + Pfailure * 2 + " N and the train weighs " + trainWeight + " N\n\n");
    }

    public void printComponents() {
        // ****** This function displays all the shapes that make up the cross section
        // with their properties
        // ******
        int i = 1;
        for (Shape shape : this.components) {
            System.out.print("Shape ");
            System.out.println(i);
            System.out.println(shape.getArea());
            System.out.println(shape.getCentroid());
            i++;
        }
    }

    public void printDetails() {
        // ****** This function displays the yBar, yTop, I, and yBot-to-yTop ratio for
        // the cross section
        System.out.println("\n\nThe yBar value is " + getYbar() + " mm");
        System.out.println("Therefore yTop is " + getYtop() + " mm");
        System.out.println("The yBot:yTop ratio is " + getYbar() / getYtop());
        System.out.println("The I value is " + getI() + " mm^4\n\n");
    }
}

import java.util.ArrayList;
import java.util.Arrays;

public class Main {
    public static void testDesign0(double Mmax, double Vmax) {
        // ***** This function makes the cross section for Design 0, calculates the yBar
        // and I values,
        // and calculates the FOS values based on a given max applied moment (Mmax) and
        // shear force (Vmax)
        // *****
        CrossSection design0 = new CrossSection();
        design0.addRect(1.27, 80, 0);
        for (int i = 0; i < 2; i++) {
            design0.addRect(72.46, 1.27, 1.27);
            design0.addRect(1.27, 6.27, 73.73);
        }
        design0.addRect(1.27, 100, 75);
        design0.printDetails();

        ArrayList<Double> glueH = new ArrayList<>(Arrays.asList(75.0));
        ArrayList<Integer> buckCaseLayers = new ArrayList<>(Arrays.asList(1, 1, 1, 1));
        ArrayList<Double> buckCaseWidths = new ArrayList<>(
                Arrays.asList(80.0, 10.0, design0.getYtop() - 1.27, design0.getYbar() + design0.getYtop() - 1.27));

        design0.printFOSAnalysis(Mmax, Vmax, glueH, buckCaseLayers, buckCaseWidths, 400);
    }

    public static void testInitial(double Mmax, double Vmax, double totalHeight) {
        // ***** This function makes the cross section for our Initial Design with a
        // given total height (totalHeight), calculates the yBar and I values,
        // and calculates the FOS values based on a given max applied moment (Mmax) and
        // shear force (Vmax)
        // *****
        CrossSection designI = new CrossSection();
        for (int i = 0; i < 3; i++) {
            if (i > 0) {
                designI.addRect(totalHeight - 4 * 1.27, 1.27, 0);
                designI.addRect(1.27, 20, totalHeight - 4 * 1.27);
            }
            designI.addRect(1.27, 100, totalHeight - 3 * 1.27 + i * 1.27);
        }
        designI.printDetails();
    }

    public static void testIteration1(double Mmax, double Vmax) {
        // ***** This function makes the cross section for our First Iteration,
        // calculates the yBar and I values,
        // and calculates the FOS values based on a given max applied moment (Mmax) and
        // shear force (Vmax)
        // *****
        CrossSection designI1 = new CrossSection();
        ArrayList<Double> glueH = new ArrayList<>();
        designI1.addRect(1.27, 75, 0);
        designI1.addRect(1.27, 75, 2.54);
        for (int i = 0; i < 3; i++) {
            if (i < 2) {
                designI1.addRect(1.27, 15, 1.27);
                designI1.addRect(72.38, 1.27, 2.54);
                designI1.addRect(69.84, 1.27, 3.81);
                designI1.addRect(1.27, 18.73, 73.65);
                designI1.addRect(1.27, 20, 74.92);
                glueH.add(1.27 + i * 1.27);
            }
            designI1.addRect(1.27, 100, 76.19 + i * 1.27);
            glueH.add(76.19 + i * 1.27);
        }
        glueH.add(74.92);

        designI1.printDetails();

        ArrayList<Integer> buckCaseLayers = new ArrayList<>(Arrays.asList(3, 3, 2, 2));
        ArrayList<Double> buckCaseWidths = new ArrayList<>(
                Arrays.asList(75.0, 12.5, designI1.getYtop() - 3 * 1.27,
                        designI1.getYbar() + designI1.getYtop() - 4 * 1.27));

        designI1.printFOSAnalysis(Mmax, Vmax, glueH, buckCaseLayers, buckCaseWidths, 400);
    }

    public static void testIteration2(double Mmax, double Vmax) {
        // ***** This function makes the cross section for our Second Iteration,
        // calculates the yBar and I values,
        // and calculates the FOS values based on a given max applied moment (Mmax) and
        // shear force (Vmax)
        // *****
        CrossSection designI2 = new CrossSection();
        ArrayList<Double> glueH = new ArrayList<>();
        designI2.addRect(1.27, 60, 0);
        designI2.addRect(1.27, 97, 73.65);
        glueH.add(1.27);
        glueH.add(74.92);
        for (int i = 0; i < 2; i++) {
            designI2.addRect(76.32, 73.65, 1.27, 1.27);
            designI2.addRect(73.69, 71.11, 1.27, 2.54);
            designI2.addRect(1.27, 10, 1.27);
            designI2.addRect(1.27, 20, 74.92);
        }
        for (int k = 0; k < 3; k++) {
            designI2.addRect(1.27, 100, 76.19 + k * 1.27);
            glueH.add(76.19 + k * 1.27);
        }
        designI2.printDetails();

        ArrayList<Integer> buckCaseLayers = new ArrayList<>(Arrays.asList(4, 4, 2, 2));
        ArrayList<Double> buckCaseWidths = new ArrayList<>(
                Arrays.asList(100.0, 1.0, designI2.getYtop() - 5 * 1.27,
                        designI2.getYbar() + designI2.getYtop() - 6 * 1.27));

        designI2.printFOSAnalysis(Mmax, Vmax, glueH, buckCaseLayers, buckCaseWidths, 400);

    }

    public static void testDesignFinalPt1(double Mmax, double Vmax, double Mratio, double Vratio) {
        // ***** This function makes the cross section for our Third Iteration,
        // calculates the yBar and I values,
        // calculates the FOS values based on given max applied moment (Mmax) and shear
        // force (Vmax),
        // and calculates the failure load P based on given applied moment in terms of P
        // (Mratio) and applied shear in terms of P (Vratio)
        // *****
        CrossSection designF1 = new CrossSection();
        ArrayList<Double> glueH = new ArrayList<>();
        designF1.addRect(1.27, 62, 0);
        for (int i = 0; i < 2; i++) {
            designF1.addRect(75.98, 73.65, 1.27, 1.27);
            designF1.addRect(1.27, 19, 74.92);
        }
        for (int k = 0; k < 3; k++) {
            designF1.addRect(1.27, 100, 76.19 + k * 1.27);
            glueH.add(76.19 + k * 1.27);
        }
        designF1.printDetails();

        ArrayList<Integer> buckCaseLayers = new ArrayList<>(Arrays.asList(3, 3, 1, 1));
        ArrayList<Double> buckCaseWidths = new ArrayList<>(
                Arrays.asList(100.0, 1.0, designF1.getYtop() - 3 * 1.27,
                        designF1.getYbar() + designF1.getYtop() - 4 * 1.27));

        designF1.printFullAnalysis(Mmax, Vmax, Mratio, Vratio, glueH, 5, buckCaseLayers, buckCaseWidths, 437);

    }

    public static void testDesignFinalPt2(double Mmax, double Vmax, double Mratio, double Vratio) {
        // ***** This function makes the cross section for our Fourth Iteration,
        // calculates the yBar and I values,
        // calculates the FOS values based on given max applied moment (Mmax) and shear
        // force (Vmax),
        // and calculates the failure load P based on given applied moment in terms of P
        // (Mratio) and applied shear in terms of P (Vratio)
        // *****
        CrossSection designF2 = new CrossSection();
        ArrayList<Double> glueH = new ArrayList<>();
        designF2.addRect(1.27, 62, 0);
        for (int i = 0; i < 2; i++) {
            designF2.addRect(75.98, 73.65, 1.27, 1.27);
            designF2.addRect(1.27, 19, 74.92);
        }
        designF2.addRect(1.27, 90, 73.65);
        glueH.add(74.92);
        for (int k = 1; k < 4; k++) {
            designF2.addRect(1.27, 100, 74.92 + k * 1.27);
            glueH.add(74.92 + k * 1.27);
        }
        designF2.printDetails();

        ArrayList<Integer> buckCaseLayers = new ArrayList<>(Arrays.asList(4, 4, 1, 1));
        ArrayList<Double> buckCaseWidths = new ArrayList<>(
                Arrays.asList(100.0, 1.0, designF2.getYtop() - 5 * 1.27,
                        designF2.getYbar() + designF2.getYtop() - 6 * 1.27));

        designF2.printFullAnalysis(Mmax, Vmax, Mratio, Vratio, glueH, 5, buckCaseLayers, buckCaseWidths, 437);

    }

    public static void main(String[] args) {
        // These values were derived from our Python code analyzing Load Case 1
        double MmaxLoad1 = 69841;
        double VmaxLoad1 = 257.6;

        // These values were derived from our Python code analyzing the base case of
        // Load Case 2
        double MmaxLoad2 = 78128;
        double VmaxLoad2 = 304.4;

        // These ratios were derived from our Python code analyzing successive cases of
        // Load Case 2
        double MratioLoad2 = 1222.71;
        double VratioLoad2 = 4.8356;

        // Testing Design 0 for Load Case 1
        testDesign0(MmaxLoad1, VmaxLoad1);

        // Testing Intital Design for Load Case 2 base case at heights of 60 mm, 80 mm,
        // and 100 mm
        testInitial(MmaxLoad2, VmaxLoad2, 60);
        testInitial(MmaxLoad2, VmaxLoad2, 80);
        testInitial(MmaxLoad2, VmaxLoad2, 100);

        // Testing First Iteration for Load Case 2
        testIteration1(MmaxLoad2, VmaxLoad2);

        // Testing Second Iteration for Load Case 2
        testIteration2(MmaxLoad2, VmaxLoad2);

        // Testing Third Iteration for Load Case 2
        testDesignFinalPt1(MmaxLoad2, VmaxLoad2, MratioLoad2, VratioLoad2);

        // Testing Fourth Iteration for Load Case 2
        testDesignFinalPt2(MmaxLoad2, VmaxLoad2, MratioLoad2, VratioLoad2);

        // ****** Uncomment and run the following block of code to input a new cross
        // section idea that is not one of the pre-defined iterations
        // It will calculate yBar and I for the cross section
        // ******

        // Scanner myobj = new Scanner(System.in);
        // System.out.print("How many shapes in your cross section? ");
        // int numShapes = myobj.nextInt();

        // Scanner myobj2 = new Scanner(System.in);
        // System.out.print("Are there diagonals (y/n)? ");
        // String ans = myobj2.nextLine();

        // CrossSection design = new CrossSection();
        // for (int i = 0; i < numShapes; i++) {
        // double l = -1.0;
        // System.out.print("For shape ");
        // System.out.println(i + 1);
        // System.out.print("How many of these are there? ");
        // int count = myobj.nextInt();
        // if (ans.equals("y")) {
        // System.out.print("Enter the actual height: ");
        // l = myobj.nextDouble();
        // }
        // System.out.print("Enter the vertical height: ");
        // double h = myobj.nextDouble();
        // System.out.print("Enter the base: ");
        // double b = myobj.nextDouble();
        // System.out.print("How high is the bottom of the shape? ");
        // double botD = myobj.nextDouble();
        // for (int k = 0; k < count; k++) {
        // if (l >= 0) {
        // design.addRect(l, h, b, botD);
        // } else {
        // design.addRect(h, b, botD);
        // }
        // }
        // i += count - 1;
        // }
        // design.printDetails();
    }
}
      </code></pre>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('bouncingCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const balls = [];
    const img = new Image();
    img.src = 'amongus.png'; // Replace with the path to your image

    img.onload = function () {
      // Create multiple bouncing objects
      for (let i = 0; i < 12; i++) {
    balls.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      dx: Math.random() * 2 + 1,
      dy: Math.random() * 2 + 1,
      size: 100,
      angle: 0, // Initial rotation angle in degrees
      rotationSpeed: Math.random() * 2 + 0.5, // Constant speed of rotation
      image: img,
    });
  }
  draw();
};

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  balls.forEach((ball) => {
    // Save canvas state
    ctx.save();

    // Translate to the center of the image
    const centerX = ball.x + ball.size / 2;
    const centerY = ball.y + ball.size / 2;
    ctx.translate(centerX, centerY);

    // Rotate the canvas
    ctx.rotate((ball.angle * Math.PI) / 180);

    // Draw the image (adjusted for rotation)
    ctx.drawImage(ball.image, -ball.size / 2, -ball.size / 2, ball.size, ball.size);

    // Restore canvas state
    ctx.restore();

    // Update position
    ball.x += ball.dx;
    ball.y += ball.dy;

    // Update rotation angle (constant spin)
    ball.angle += ball.rotationSpeed;

    // Bounce off walls
    if (ball.x < 0 || ball.x + ball.size > canvas.width) ball.dx *= -1;
    if (ball.y < 0 || ball.y + ball.size > canvas.height) ball.dy *= -1;
  });

  requestAnimationFrame(draw);
}

    function switchTab(tabId) {
      document.querySelectorAll('.tab-content').forEach((tab) => {
        tab.classList.remove('active');
      });
      document.querySelectorAll('.tab-button').forEach((button) => {
        button.classList.remove('active');
      });
      document.getElementById(tabId).classList.add('active');
      document.querySelector(`[onclick="switchTab('${tabId}')"]`).classList.add('active');
    }
  </script>
</body>
</html>
